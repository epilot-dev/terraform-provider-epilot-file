// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-file/internal/sdk/internal/utils"
	"time"
)

type Schema string

const (
	SchemaFile Schema = "file"
)

func (e Schema) ToPointer() *Schema {
	return &e
}
func (e *Schema) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = Schema(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Schema: %v", v)
	}
}

type AccessControl string

const (
	AccessControlPrivate    AccessControl = "private"
	AccessControlPublicRead AccessControl = "public-read"
)

func (e AccessControl) ToPointer() *AccessControl {
	return &e
}
func (e *AccessControl) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "private":
		fallthrough
	case "public-read":
		*e = AccessControl(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccessControl: %v", v)
	}
}

type FileEntityS3ref struct {
	Bucket string `json:"bucket"`
	Key    string `json:"key"`
}

func (f *FileEntityS3ref) GetBucket() string {
	if f == nil {
		return ""
	}
	return f.Bucket
}

func (f *FileEntityS3ref) GetKey() string {
	if f == nil {
		return ""
	}
	return f.Key
}

type FileEntity struct {
	// Additional fields that are not part of the schema
	Additional map[string]any `json:"__additional,omitempty"`
	// Access control list (ACL) for an entity. Defines sharing access to external orgs or users.
	ACL       *BaseEntityACL `json:"_acl,omitempty"`
	CreatedAt *time.Time     `json:"_created_at,omitempty"`
	ID        string         `json:"_id"`
	// Manifest ID used to create/update the entity
	Manifest      []string          `json:"_manifest,omitempty"`
	Org           string            `json:"_org"`
	Owners        []BaseEntityOwner `json:"_owners,omitempty"`
	Purpose       []string          `json:"_purpose,omitempty"`
	Schema        Schema            `json:"_schema"`
	Tags          []string          `json:"_tags,omitempty"`
	Title         string            `json:"_title"`
	UpdatedAt     *time.Time        `json:"_updated_at,omitempty"`
	AccessControl *AccessControl    `default:"private" json:"access_control"`
	// Custom external download url used for the file
	CustomDownloadURL *string `json:"custom_download_url,omitempty"`
	Filename          string  `json:"filename"`
	// MIME type of the file
	MimeType *string `json:"mime_type,omitempty"`
	// Direct URL for file (public only if file access control is public-read)
	PublicURL *string `json:"public_url,omitempty"`
	// Human readable file size
	ReadableSize *string          `json:"readable_size,omitempty"`
	S3ref        *FileEntityS3ref `json:"s3ref,omitempty"`
	// File size in bytes
	SizeBytes *int64 `json:"size_bytes,omitempty"`
	// Source URL for the file. Included if the entity was created from source_url, or when ?source_url=true
	SourceURL *string    `json:"source_url,omitempty"`
	Type      FileType   `json:"type"`
	Versions  []FileItem `json:"versions"`
}

func (f FileEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FileEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"_id", "_org", "_schema", "_title", "filename", "type", "versions"}); err != nil {
		return err
	}
	return nil
}

func (f *FileEntity) GetAdditional() map[string]any {
	if f == nil {
		return nil
	}
	return f.Additional
}

func (f *FileEntity) GetACL() *BaseEntityACL {
	if f == nil {
		return nil
	}
	return f.ACL
}

func (f *FileEntity) GetCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAt
}

func (f *FileEntity) GetID() string {
	if f == nil {
		return ""
	}
	return f.ID
}

func (f *FileEntity) GetManifest() []string {
	if f == nil {
		return nil
	}
	return f.Manifest
}

func (f *FileEntity) GetOrg() string {
	if f == nil {
		return ""
	}
	return f.Org
}

func (f *FileEntity) GetOwners() []BaseEntityOwner {
	if f == nil {
		return nil
	}
	return f.Owners
}

func (f *FileEntity) GetPurpose() []string {
	if f == nil {
		return nil
	}
	return f.Purpose
}

func (f *FileEntity) GetSchema() Schema {
	if f == nil {
		return Schema("")
	}
	return f.Schema
}

func (f *FileEntity) GetTags() []string {
	if f == nil {
		return nil
	}
	return f.Tags
}

func (f *FileEntity) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FileEntity) GetUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.UpdatedAt
}

func (f *FileEntity) GetAccessControl() *AccessControl {
	if f == nil {
		return nil
	}
	return f.AccessControl
}

func (f *FileEntity) GetCustomDownloadURL() *string {
	if f == nil {
		return nil
	}
	return f.CustomDownloadURL
}

func (f *FileEntity) GetFilename() string {
	if f == nil {
		return ""
	}
	return f.Filename
}

func (f *FileEntity) GetMimeType() *string {
	if f == nil {
		return nil
	}
	return f.MimeType
}

func (f *FileEntity) GetPublicURL() *string {
	if f == nil {
		return nil
	}
	return f.PublicURL
}

func (f *FileEntity) GetReadableSize() *string {
	if f == nil {
		return nil
	}
	return f.ReadableSize
}

func (f *FileEntity) GetS3ref() *FileEntityS3ref {
	if f == nil {
		return nil
	}
	return f.S3ref
}

func (f *FileEntity) GetSizeBytes() *int64 {
	if f == nil {
		return nil
	}
	return f.SizeBytes
}

func (f *FileEntity) GetSourceURL() *string {
	if f == nil {
		return nil
	}
	return f.SourceURL
}

func (f *FileEntity) GetType() FileType {
	if f == nil {
		return FileType("")
	}
	return f.Type
}

func (f *FileEntity) GetVersions() []FileItem {
	if f == nil {
		return []FileItem{}
	}
	return f.Versions
}
