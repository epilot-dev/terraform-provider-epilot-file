// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-file/internal/sdk/internal/utils"
)

type AccessControl string

const (
	AccessControlPrivate    AccessControl = "private"
	AccessControlPublicRead AccessControl = "public-read"
)

func (e AccessControl) ToPointer() *AccessControl {
	return &e
}
func (e *AccessControl) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "private":
		fallthrough
	case "public-read":
		*e = AccessControl(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccessControl: %v", v)
	}
}

// Type - Human readable type for file
type Type string

const (
	TypeDocument         Type = "document"
	TypeDocumentTemplate Type = "document_template"
	TypeText             Type = "text"
	TypeImage            Type = "image"
	TypeVideo            Type = "video"
	TypeAudio            Type = "audio"
	TypeSpreadsheet      Type = "spreadsheet"
	TypePresentation     Type = "presentation"
	TypeFont             Type = "font"
	TypeArchive          Type = "archive"
	TypeApplication      Type = "application"
	TypeUnknown          Type = "unknown"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "document":
		fallthrough
	case "document_template":
		fallthrough
	case "text":
		fallthrough
	case "image":
		fallthrough
	case "video":
		fallthrough
	case "audio":
		fallthrough
	case "spreadsheet":
		fallthrough
	case "presentation":
		fallthrough
	case "font":
		fallthrough
	case "archive":
		fallthrough
	case "application":
		fallthrough
	case "unknown":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type Versions struct {
	S3ref *S3Reference `json:"s3ref,omitempty"`
}

func (o *Versions) GetS3ref() *S3Reference {
	if o == nil {
		return nil
	}
	return o.S3ref
}

type FileEntity struct {
	ID            *string        `json:"_id,omitempty"`
	AccessControl *AccessControl `default:"private" json:"access_control"`
	Filename      *string        `json:"filename,omitempty"`
	// MIME type of the file
	MimeType *string `json:"mime_type,omitempty"`
	// Direct URL for file (public only if file access control is public-read)
	PublicURL *string `json:"public_url,omitempty"`
	// File size in bytes
	SizeBytes *int64 `json:"size_bytes,omitempty"`
	// Human readable type for file
	Type     *Type      `json:"type,omitempty"`
	Versions []Versions `json:"versions,omitempty"`
}

func (f FileEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FileEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *FileEntity) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *FileEntity) GetAccessControl() *AccessControl {
	if o == nil {
		return nil
	}
	return o.AccessControl
}

func (o *FileEntity) GetFilename() *string {
	if o == nil {
		return nil
	}
	return o.Filename
}

func (o *FileEntity) GetMimeType() *string {
	if o == nil {
		return nil
	}
	return o.MimeType
}

func (o *FileEntity) GetPublicURL() *string {
	if o == nil {
		return nil
	}
	return o.PublicURL
}

func (o *FileEntity) GetSizeBytes() *int64 {
	if o == nil {
		return nil
	}
	return o.SizeBytes
}

func (o *FileEntity) GetType() *Type {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *FileEntity) GetVersions() []Versions {
	if o == nil {
		return nil
	}
	return o.Versions
}
